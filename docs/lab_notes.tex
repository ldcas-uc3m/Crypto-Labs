\documentclass[a4paper, 12 pt]{memoir}
\usepackage[utf8]{inputenc}
\usepackage[table]{xcolor}
\usepackage{listings}
\usepackage{float} 
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{amsfonts}
\usepackage{hyperref}

\definecolor{azulUC3M}{RGB}{0,0,102}

\geometry{asymmetric}

\begin{document}

\chapter{General knowledge}

\section{Converting data}

\subsection{Binary to hexadecimal}
Use python built-in functions.
\begin{lstlisting}[language=Python]
    bin_data = b"data"
    hex_data = bin_data.hex()
    bin_data = bytes.fromhex(hex_data)
\end{lstlisting}

\subsection{Binary to base 64}
Use python module \textbf{base64}.
\begin{lstlisting}[language=Python]
    import base64

    bin_data = b"data"
    b64_data = base64.b64encode(bin_data)
    bin_data = base64.b64decode(b64_data)
\end{lstlisting}

\section{PKCS7 Padding}
Some block cyphers might require padding. The order of operation must always be:
\begin{enumerate}
    \item Pad data
    \item Encrypt padded data
    \item Exchange data
    \item Decrypt encrypted data
    \item Unpad plaintext
\end{enumerate}

\begin{lstlisting}[language=Python]
    from cryptography.hazmat.primitives import padding

    padder = padding.PKCS7(block_size).padder()
    padded_data = padder.update(data) + padder.finalize()

    unpadder = padding.PKCS7(block_size).unpadder()
    data = unpadder.update(padded_data) + unpadder.finalize()

\end{lstlisting}


\section{Randomization}
\subsection{Random keystream}
You can generate a random string of bytes by using an OS function.

\begin{lstlisting}[language=Python]
    import os

    rand = os.urandom(num_bytes)
\end{lstlisting}

\subsection{LFSR keystream}
This is included in the \textbf{pylfsr} module.
\begin{lstlisting}[language=Python]
    from pylfsr import LFSR

    seed = [0, 0, 0, 1, 0]
    fpoly = [3, 2, 1]  # c3=1, c2=1, c1=1
    L = LFSR(fpoly = fpoly, initstate = seed, verbose = True)

    seq = L.runKCycle(num_bits)
\end{lstlisting}


\chapter{Symmetric encryption}

\section{AES256}
AES256 is a \textbf{block cypher algorithm} with a 32B key, and it can use different modes of operation. The general syntax is:

\begin{lstlisting}[language=Python]
    from cryptography.hazmat.primitives.ciphers \
        import Cipher, algorithms, modes

    block_size = 16  # e.g.
    key = os.urandom(32)
    iv = os.urandom(block_size)  # if needed, depends on mode
    nonce = os.urandom(block_size)  # if needed, depends on mode
    
    message = b"A secret message"  # must be binary

    cypher = Cypher(algorithms.AES(key), mode = <mode>)

    encryptor = cypher.encryptor()
    ct = encryptor.update(message) + encryptor.finalize

    decryptor = cypher.decryptor()
    pt = decryptor.update(ct) + decryptor.finalize
\end{lstlisting}

\subsection{CBC mode}
Needs an Initialization Vector.
\begin{lstlisting}[language=Python]
    cypher = Cypher(algorithms.AES(key), modes.CBC(iv))
\end{lstlisting}

\subsection{ECB mode}
Padding is required.
\begin{lstlisting}[language=Python]
    cypher = Cypher(algorithms.AES(key), modes.ECB())
\end{lstlisting}

\subsection{CTR mode}
\label{sec:AES256 CTR}
Requires a nonce (unique and never reused). This mode is not reccomended for block cyphers with a block size of less than 128b.
\begin{lstlisting}[language=Python]
    cypher = Cypher(algorithms.AES(key), modes.CTR(nonce))
\end{lstlisting}

\subsection{Effects of modifying ciphertexts in different modes}
\begin{itemize}
    \item \textbf{CBC and ECB modes:} The entire block of the altered byte is corrupted.
    \item \textbf{CTR mode:} Only the affected byte is corrupted.
\end{itemize}

\section{ChaCha20}
ChaCha20 is a \textbf{stream cypher algorithm}. It requires a 32B key and a 16B nonce.
\begin{lstlisting}[language=Python]
    nonce = os.urandom(16)

    cipher = Cipher(algorithms.ChaCha20(key, nonce), mode=None)

    encryptor = cipher.encryptor()
    ct = encryptor.update(message)
    
    decryptor = cipher.decryptor()
    pt = decryptor.update(ct)
\end{lstlisting}


\chapter{Assymetric encrytption}

\section{RSA}

\subsection{RSA key generation}
\begin{lstlisting}[language=Python]
    from cryptography.hazmat.primitives.asymmetric import rsa

    key_size = 2048
    public_exponent = 65537
    
    priv_key = rsa.generate_private_key(
        public_exponent,key_size
    )

    pub_key = priv_key.public_key()
\end{lstlisting}

We can obtaint the numbers from the key pair:
\begin{lstlisting}[language=Python]
    u = pub_key.public_numbers()
    e = u.e
    n = u.n

    v = priv_key.private_numbers()
    p = v.p
    q = v.q
    d = v.d
\end{lstlisting}

\subsection{PEM serialization}
To output the key pair in PEM format:
\begin{lstlisting}[language=Python]
    from cryptography.hazmat.primitives.serialization \
    import load_pem_private_key, load_pem_public_key
    from cryptography.hazmat.primitives import serialization
    
    encoding = serialization.Encoding.PEM

    # public key
    format = serialization.PublicFormat.SubjectPublicKeyInfo
    pem_pub_key = pub_key.public_bytes(encoding, format)
    
    # private key
    format = serialization.PrivateFormat.TraditionalOpenSSL
    
    pwd = b"password"  # e.g.
    encryption_algorithm = serialization.BestAvailableEncryption(pwd)

    pem_priv_key = priv_key.private_bytes(
        encoding, format, encryption_algorithm
    )
\end{lstlisting}

You can deserialize a serialized PEM key with:
\begin{lstlisting}[language=Python]
    pub_key = load_pem_public_key(pem_pub_key)
    priv_key = load_pem_private_key(pem_priv_key, pwd)
    
\end{lstlisting}

\subsection{RSA encryption/decryption (with padding)}
\begin{lstlisting}[language=Python]
    padder = padding.PKSC1v15()

    ct = public_key.encrypt(message, padder)
    
    pt = public_key.decrypt(message, padder)
\end{lstlisting}

For OAEP padding, we need to set the padder as:
\begin{lstlisting}
    padder = padding.OAEP(
        mgf = padding.MGF1(
            algorithms.hashes.SHA256()
        ),
        algorithm = hashes.SHA256(),
        label = None
    )
\end{lstlisting}

Note that encrypting the same message won't give the same cyphertext when using PKCS1v15 and OAEP padding, as there is a random bytes string appended.

\chapter{Hybrid encryption (RSA OAEP + AES256 CTR)}
\begin{enumerate}
    \item Encrypt the symmetric AES key with the public RSA key and add padding.
    \begin{lstlisting}[language=Python]
        encrypted_sym_key = pub_key.encrypt(key, padder)
    \end{lstlisting}
    \item Generate a nonce.
    \begin{lstlisting}[language=Python]
        nonce = os.urandom(block_size)
    \end{lstlisting}
    \item Encrypt with AES in CTR mode
    \hyperref[sec:AES256 CTR]{(see AES256 CTR)}.
\end{enumerate}

To decrypt: 
\begin{enumerate}
    \item Decrypt and unpad the AES key with the private RSA key.
    \begin{lstlisting}[language=Python]
        key = priv_key.decrypt(encrypted_key, padder)
    \end{lstlisting}
    \item Decrypt the cyphertext with AES in CTR mode
    \hyperref[sec:AES256 CTR]{(see AES256 CTR)}.
\end{enumerate}


\chapter{Key exchange}

\subsection{AES key wrapping}
Key wrapping is encrypting a symmetric key using another symmetric key in order to transmit it through an untrusted channel.

\begin{lstlisting}[language=Python]
from cryptography.hazmat.primitives.keywrap \
    import aes_key_wrap, aes_key_unwrap

    wrapped_key = aes_key_wrap(wrapping_key, key)
    key = aes_key_unwrap(wrapping_key, wrapped_key)
\end{lstlisting}


\end{document}